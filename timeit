#!/usr/bin/env python

#
# Runs a command several times, measures execution time, and prints combined results of all runs
#


import sys
import getopt
import subprocess
import timeit


def usage():
    print "Usage: %s [-r <num runs>] [-s|--shell] <command line>" % sys.argv[0]

if __name__ == "__main__":
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hr:s", ["help", "runs=", "shell"])
    except getopt.GetoptError as err:
        print str(err)
        usage()
        sys.exit(2)
    numRuns = 3
    runInShell = False
    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit()
        elif o in ("-r", "--runs"):
            numRuns = int(a)
        elif o in ("-s", "--shell"):
            runInShell = True
        else:
            assert False, "internal error (unhandled option)"

    if numRuns < 1:
        print "error: -r parameter must be >= 1"
        sys.exit(2)

    wallclocks = []
    for i in range(numRuns):
        startTime = timeit.default_timer()
        subprocess.call(args, shell=runInShell)
        endTime = timeit.default_timer()
        wallclocks.append(endTime - startTime)

    sys.stderr.write("wallclock: avg=%.3fs; range=%.3fs (%.3fs - %.3fs); runs=%d\n" % (
        float(sum(wallclocks))/len(wallclocks), (max(wallclocks)-min(wallclocks)), min(wallclocks), max(wallclocks), len(wallclocks)))
