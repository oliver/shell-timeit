#!/usr/bin/env python

#
# Runs a command several times, measures execution time, and prints combined results of all runs
#


import sys
import os
import getopt
import subprocess
import time
import datetime
import timeit
import json


def appendResults(destPath, message, startTime, endTime, command, wallclocks):
    data = {
        "start":datetime.datetime.utcfromtimestamp(startTime).isoformat() + "Z",
        "end":datetime.datetime.utcfromtimestamp(endTime).isoformat() + "Z",
        "command":command,
        "results":{
            "wallclock": wallclocks,
            }
        }
    if message is not None:
        data["message"] = message

    fp = open(destPath, "a")
    json.dump(data, fp)
    fp.write("\n")
    fp.close()


def parseIsoDatetime(s):
     return datetime.datetime.strptime(s, "%Y-%m-%dT%H:%M:%S.%fZ" )

def readResultFile(srcPath):
    fp = open(srcPath)
    rawData = fp.read()
    fp.close()

    results = []
    decoder = json.JSONDecoder()
    while rawData:
        lineData, length = decoder.raw_decode(rawData)
        lineData["start"] = parseIsoDatetime(lineData["start"])
        lineData["end"] = parseIsoDatetime(lineData["end"])
        results.append(lineData)
        rawData = rawData[length:].lstrip()
    return results


def createDiagram(destPath, allResults):
    import matplotlib.pyplot as plt

    xLabels = []
    wallclockMins = []
    wallclockRanges = []
    pointsX = []
    pointsY = []
    lastDate = None
    i = 1
    for r in allResults:
        if lastDate is None or lastDate != r["start"].date():
            label = r["start"].strftime("%Y-%d-%m %H:%M:%S")
        else:
            label = r["start"].strftime("%H:%M:%S")
        lastDate = r["start"].date()

        if "message" in r:
            label = r["message"] + "\n" + label
        else:
            label = " ".join(r["command"]) + "\n" + label
        xLabels.append(label)

        wallclockMin = min(r["results"]["wallclock"])
        wallclockMax = max(r["results"]["wallclock"])
        wallclockMins.append(wallclockMin)
        wallclockRanges.append(wallclockMax - wallclockMin)

        for t in r["results"]["wallclock"]:
            pointsX.append(i)
            pointsY.append(t)
        i+=1

    yErrors = ( [0]*len(wallclockRanges), wallclockRanges )

    fig = plt.figure()
    ax = fig.add_axes([0.1, 0.2, 0.85, 0.75])
    ax.set_xlim(0.5, len(wallclockMins)+0.5)
    ax.bar(range(1, len(wallclockMins)+1), wallclockMins, align="center", yerr=yErrors, ecolor="black")
    ax.plot(pointsX, pointsY, "o")
    ax.xaxis.set_ticks(range(1, len(wallclockMins)+1))
    ax.xaxis.set_ticklabels(xLabels, rotation=90, fontsize=8)
    plt.ylabel("Wallclock Time [s]")
    plt.savefig(destPath)


def usage():
    print "Usage: %s [-r <num runs>] [-s|--shell] [-f|--file=<results.json>] [-m|--message <free-text message>] [-o|--output=<output.png/.svg>] <command line>" % sys.argv[0]

if __name__ == "__main__":
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hr:sf:m:o:", ["help", "runs=", "shell", "file=", "message=", "output="])
    except getopt.GetoptError as err:
        print str(err)
        usage()
        sys.exit(2)

    numRuns = 3
    runInShell = False
    resultFile = None
    message = None
    outputFiles = []
    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit()
        elif o in ("-r", "--runs"):
            numRuns = int(a)
        elif o in ("-s", "--shell"):
            runInShell = True
        elif o in ("-f", "--file"):
            resultFile = a
        elif o in ("-m", "--message"):
            message = a
        elif o in ("-o", "--output"):
            outputFiles.append(a)
        else:
            assert False, "internal error (unhandled option)"

    if numRuns < 1:
        print "error: -r parameter must be >= 1"
        sys.exit(2)

    command = args

    if not(command) and not(outputFiles):
        print "error: must specify at least a command or an output file"
        usage()
        sys.exit(2)

    if command:
        if resultFile is not None:
            if not(os.path.exists(resultFile)):
                open(resultFile, "w").close()

        overallStartTime = time.time()
        wallclocks = []
        for i in range(numRuns):
            startTime = timeit.default_timer()
            subprocess.call(command, shell=runInShell)
            endTime = timeit.default_timer()
            wallclocks.append(endTime - startTime)
        overallEndTime = time.time()

        sys.stderr.write("wallclock: avg=%.3fs; range=%.3fs (%.3fs - %.3fs); runs=%d\n" % (
            float(sum(wallclocks))/len(wallclocks), (max(wallclocks)-min(wallclocks)), min(wallclocks), max(wallclocks), len(wallclocks)))

        if resultFile is not None:
            appendResults(resultFile, message, overallStartTime, overallEndTime, command, wallclocks)

    if outputFiles:
        if resultFile is None:
            raise NotImplementedError("cannot create diagram for single value")
        else:
            allResults = readResultFile(resultFile)
        for path in outputFiles:
            createDiagram(path, allResults)
