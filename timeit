#!/usr/bin/env python

#
# Runs a command several times, measures execution time, and prints combined results of all runs
#


import sys
import os
import getopt
import subprocess
import time
import datetime
import timeit
import json
import resource
import re


ELLIPSIS_CHAR = u"\u2026"


def appendResults(destPath, message, startTime, endTime, command, resultMap):
    data = {
        "start":datetime.datetime.utcfromtimestamp(startTime).isoformat() + "Z",
        "end":datetime.datetime.utcfromtimestamp(endTime).isoformat() + "Z",
        "command":command,
        "results":{}
            }

    for key in resultMap.keys():
        data["results"][key] = resultMap[key]

    if message is not None:
        data["message"] = message

    fp = open(destPath, "a")
    json.dump(data, fp)
    fp.write("\n")
    fp.close()


def parseIsoDatetime(s):
     return datetime.datetime.strptime(s, "%Y-%m-%dT%H:%M:%S.%fZ" )

def readResultFile(srcPath):
    fp = open(srcPath)
    rawData = fp.read()
    fp.close()

    results = []
    decoder = json.JSONDecoder()
    while rawData:
        lineData, length = decoder.raw_decode(rawData)
        lineData["start"] = parseIsoDatetime(lineData["start"])
        lineData["end"] = parseIsoDatetime(lineData["end"])
        results.append(lineData)
        rawData = rawData[length:].lstrip()
    return results


def createDiagram(destPath, allResults, measurementName):
    import matplotlib.pyplot as plt

    # TODO: add all values from resource package:
    knownMeasurementNames = {
        "wallclock": "Wallclock Time [s]",
        "ru_utime": "User Mode Time [s]",
        "ru_stime": "System Mode Time [s]",
    }

    if measurementName in knownMeasurementNames:
        measurementDesc = knownMeasurementNames[measurementName]
    else:
        measurementDesc = measurementName

    xLabels = []
    valueMins = []
    valueRanges = []
    pointsX = []
    pointsY = []
    lastDate = None
    i = 1
    for r in allResults:
        if lastDate is None or lastDate != r["start"].date():
            label = r["start"].strftime("%Y-%d-%m %H:%M:%S")
        else:
            label = r["start"].strftime("%H:%M:%S")
        lastDate = r["start"].date()

        if "message" in r:
            label = r["message"] + "\n" + label
        else:
            cmd = " ".join(r["command"])
            if len(cmd) > 50:
                cmd = cmd[:30] + ELLIPSIS_CHAR + cmd[-17:]
            label = cmd + "\n" + label
        xLabels.append(label)

        if not(measurementName in r["results"]):
            raise ValueError("measurement \"%s\" is not available in result data. Available are: %s" % (
                measurementName, " ".join(sorted(r["results"].keys()))))

        valueMin = min(r["results"][measurementName])
        valueMax = max(r["results"][measurementName])
        valueMins.append(valueMin)
        valueRanges.append(valueMax - valueMin)

        for t in r["results"][measurementName]:
            pointsX.append(i)
            pointsY.append(t)
        i+=1

    numResults = len(allResults)
    yErrors = ( [0]*numResults, valueRanges )

    fig, ax = plt.subplots()
    ax.set_xlim(0.5, numResults+0.5)
    ax.bar(range(1, numResults+1), valueMins, align="center", yerr=yErrors, ecolor="black")
    ax.plot(pointsX, pointsY, "o")
    ax.xaxis.set_ticks(range(1, numResults+1))
    ax.xaxis.set_ticklabels(xLabels, rotation=90, fontsize=8)
    plt.ylabel(measurementDesc)
    try:
        plt.tight_layout()
    except ValueError:
        # workaround for https://github.com/matplotlib/matplotlib/issues/5456 which occurs with very long labels:
        print "Note: could not apply tight layout; using default margins instead."
        ax.margins(0.1, 0.1)
    plt.savefig(destPath)


def usage():
    print "Usage: %s [-r <num runs>] [-s|--shell] [-f|--file=<results.json>] [-m|--message <free-text message>] [-o|--output=[measurement=]<output.png/.svg>] <command line>" % sys.argv[0]

if __name__ == "__main__":
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hr:sf:m:o:", ["help", "runs=", "shell", "file=", "message=", "output="])
    except getopt.GetoptError as err:
        print str(err)
        usage()
        sys.exit(2)

    numRuns = 3
    runInShell = False
    resultFile = None
    message = None
    outputFiles = []
    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit()
        elif o in ("-r", "--runs"):
            numRuns = int(a)
        elif o in ("-s", "--shell"):
            runInShell = True
        elif o in ("-f", "--file"):
            resultFile = a
        elif o in ("-m", "--message"):
            message = a
        elif o in ("-o", "--output"):
            outputFiles.append(a)
        else:
            assert False, "internal error (unhandled option)"

    if numRuns < 1:
        print "error: -r parameter must be >= 1"
        sys.exit(2)

    command = args

    if not(command) and not(outputFiles):
        print "error: must specify at least a command or an output file"
        usage()
        sys.exit(2)

    if command:
        if resultFile is not None:
            if not(os.path.exists(resultFile)):
                open(resultFile, "w").close()

        overallStartTime = time.time()
        results = {"wallclock":[]}
        for i in range(numRuns):
            startUsage = resource.getrusage(resource.RUSAGE_CHILDREN)
            startTime = timeit.default_timer()
            subprocess.call(command, shell=runInShell)
            endTime = timeit.default_timer()
            endUsage = resource.getrusage(resource.RUSAGE_CHILDREN)

            results["wallclock"].append(endTime - startTime)
            for field in dir(endUsage):
                if field.startswith("ru_"):
                    startVal = getattr(startUsage, field)
                    endVal = getattr(endUsage, field)
                    if not(field in results):
                        results[field] = []
                    results[field].append(endVal - startVal)
        overallEndTime = time.time()

        wallclocks = results["wallclock"]
        sys.stderr.write("wallclock: avg=%.3fs; range=%.3fs (%.3fs - %.3fs); runs=%d\n" % (
            float(sum(wallclocks))/len(wallclocks), (max(wallclocks)-min(wallclocks)), min(wallclocks), max(wallclocks), len(wallclocks)))

        if resultFile is not None:
            appendResults(resultFile, message, overallStartTime, overallEndTime, command, results)

    if outputFiles:
        if resultFile is None:
            raise NotImplementedError("cannot create diagram for single value")
        else:
            allResults = readResultFile(resultFile)

        for pathEntry in outputFiles:
            # output file arguments may optionally be preceded by the measurement name to plot:
            matches = re.match(r"([\w_]+)=(.+)$", pathEntry)
            if matches:
                (measurementName, path) = matches.groups()
                createDiagram(path, allResults, measurementName)
            else:
                createDiagram(pathEntry, allResults, "wallclock")
